include MiniKanrenImpl

(* module Tester = *)
(* struct *)
(*   let run reifier n runner goal = *)
(*     let graph = Logger.create () in *)
(*     M.run graph (fun st -> *)
(*                  let (repr, result), vars = runner goal st in *)
(*                  let (_: state Stream.t) = result in *)
(*                  Printf.printf "%s, %s answer%s {\n" *)
(*       repr *)
(*       (if n = (-1) then "all" else string_of_int n) *)
(*       (if n <>  1  then "s" else ""); *)

(*     let answers = *)
(*       (\* GraphLogger.dump_graph (Obj.magic graph) stdout; *\) *)
(*       for i=1 to n do *)
(*         ignore (take' ~n:i result); *)
(*         GraphLogger.next_level (Obj.magic graph); *)
(*       done; *)
(*       take' ~n result *)
(*     in *)

(*     let text_answers = *)
(*       answers |> List.map *)
(*         (fun (st: State.t) -> *)
(*          let s = List.map *)
(*                    (fun (s, x) -> *)
(*                     let v, dc = refine st x in *)
(*               (\* let pv = printer v in *\) *)
(*               match reifier dc v with *)
(*               | "" -> sprintf "%s=%s;" s (show_logic_naive v) *)
(*               | r  -> sprintf "%s=%s (%s);" s (show_logic_naive v) r *)
(*              ) *)
(*              vars |> String.concat " " *)
(*            in *)
(*            Printf.printf "%s\n%!" s; *)
(*            s *)
(*         ) *)
(*     in *)


(*     Printf.printf "}\n%!"; *)

(*     (\* GraphLogger.dump_graph (Obj.magic graph) stdout; *\) *)
(*     if config.do_plain then *)
(*       let out_file_prefix = Str.global_replace (Str.regexp " ") "_" repr in *)
(*       let _ = Logger.output_plain ~filename:(out_file_prefix^".plain") graph in *)
(*       (); *)
(*     if config.do_html *)
(*     then Logger.output_html  ~filename:(out_file_prefix^".html") text_answers graph; *)
(*   ) *)

(* end *)

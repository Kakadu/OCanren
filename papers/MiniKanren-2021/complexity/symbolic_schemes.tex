\section{Analysis via symbolic execution schemes}

In the previous sections we presented the methods to estimate time complexity of scheduling and unification and reification (later two only for some practical cases) in \mK, but they do it only for relational search in general, not for specific relational programs. In this section we show how the later task can be formulated and how the given methods can be combined to solve it using notions from symbolic execution. Specifically, we add symbolic variables to \mK and use symbolic execution schemes to extract recursive inequlities for different times that can then be solved to get the asymptotics.

The application of symbolic execution for time complexity analysis is well-known and was explored for logic programming in particular~\cite{SymbolicExecutionForAnalysis}. Usually, symbolic execution graphs are used to capture all the details of program execution significant for performance and then the standard techniques for time (or other) analysis of rewriting systems are applied. In contrast, we need a symbolic execution graphs only as a nice representation of a general scheme of a relational search for a given program and then bring in performance details using ad hoc methods described in the previous sections. So we use a limited version of a graph that corresponds precisely to a body of a relation, not unfolding any relational calls. For this reason we refer to them as ``symbolic execution schemes'' rather than ``symbolic execution graphs''. This also means that we suppose that we know what answers any relational call in the program produces before we start time complexity analysis.

\begin{figure}[t]
\begin{lstlisting}
   prefix$^o$ = fun n p ->
     (p === Nil) \/
     (fresh (n' pt pti)
        (n === S n') /\
        (prefix$^o$ n' pt) /\
        (incr-list$^o$ pt pti) /\
        (p === Cons(O, pti))
     )
\end{lstlisting}

\caption{Prefixes relation example}
\label{fig:prefixo_definition}
\end{figure}

To present the whole process in a clearer way we will go through it with a specific artificial example, in which almost all important details occur. The example is a relational program for generating all prefixes of a list \lstinline|[$0$, .., $n - 1$]| (with numbers represented by terms as unary numbers with constructors \lstinline|O| and \lstinline|S|). Consider the following creative recursive solution: we either take the empty prefix or take any prefix for the same task for $n - 1$ (if $n > 0$), increment all the elements and add $0$ in the beginning. The relation \lstinline|prefix$^o$| on \figureword~\ref{fig:prefixo_definition}, relating a number $n$ to some prefix $p$, follows this description directly. It uses a relation \lstinline|incr-list$^o$| that increments all numbers in a given list, we exclude its implementation from consideration (it is straightforward). This relation provides the required results: if we instantiate $n$ with some unary numbers and put a free logical variable for $p$ in the answers provided by the search then $p$ will be bound to every prefix exactly once. It is an inefficient solution in many ways, but it is nice for presentation.

Now we want to estimate the time the search will take depending on a number we put as the input. To make our reasoning more precise we introduce the notion of \emph{symbolic variables}, which we will denote by overline ($\overline{a}, \overline{b}, \dots$) as opposed to the usual logic variables, which we will denote by underline ($\underline{a}, \underline{b}, \dots$). The symbolic variables can be viewed from two levels. At the level of symbolic execution each symbolic variable in \mK stands for some ground term (a term without logic variables inside), but we do not know which term exactly. At the metalevel, where we reason about complexity of a program, a symbolic variable $\overline{x}$ stands for a representation of some object $x$ from metatheory (it can be a number, a string or a graph, for example) as a ground term, and we are analyzing how the program will behave depending on this object or some of its parameters. We will distinguish between these two levels throughout the whole process of complexity analysis. For our example we consider the parametric query \lstinline{prefix$^o$ $\overline{k}$ $\underline{a}$} with the first parameter instantiated by some number $k$ represented as a ground term with unary numeral system, and ask how much time the search and its different stages will take depending on the value of $k$.

Our approach estimates time for some specific relational call with symbolic variables, not for a relation in general. We name every call we encounter to use these names in our notations throughout the analysis (for example $pref = $ \lstinline{prefix$^o$ $\overline{k}$ $\underline{a}$}). During the analysis we separately estimate the complexity of a number of time metrics for the query that together constitute the time of the search: the number of semantic steps $d^{pref}(k)$ and the scheduling factor $t_s^{pref}(k)$, that correspond to the functions $d(\cdot)$ and $t(\cdot)$ defined in \sectionword~\ref{sec:scheduling} (they are the values of these functions on a state corresponding to the examined call), $t_{uni}^{pref}(k)$, which is the number of basic operations performed during unifications in the execution of the call, exluding basic operations in occurs checks, $t_{occ}^{pref}(k)$, which is the number of basic operations performed during occurs checks, and $t_r^{pref}(k)$, which is the number of basic operations performed during the reification. To do it, we build a symbolic execution scheme, mirroring the body of the examined relation, idetify recursive calls in it and write done recursive inequalities for all the metrics based on it by applying estimates described in the previous sections. We have a number of restrictions on the examined relational call for our approach (however, as can been seen from the \sectionword~\ref{sec:evaluation} the huge variety of real examples satisfy it): relations should be in disjunctive normal form, in the result all the logical variables in the query should be bound to ground terms, and two practical tests described in \sectionword~\ref{sec:unification} should be satisfied (which we can check using the symbolic execution schemes too). Two additional things we need to know to perform the analysis for a given call. Firstly, to  know how to proceed after recursive calls we need to know the answers that the call produces. We describe them by the set of substitutions binding all the logical variables in the query to a fresh symbolic variables, which we then specify in the metatheory (for example, $ANS^{pref}(k) = \{[\underline{a} \gets \overline{p}] \mid \textit{$p$ is a prefix of the list \texttt{\lstinline|[$0$, .., $n - 1$]|}} \} $). Secondly, we need to have all the information for non-recursive relational calls in the scheme (complexity of all the metrics, produced answers, whether the practical tests are satisfied), so we need to go and analyze these calls using the same approach before we can examine the given call or reuse the information if we have already analyzed the needed call before. For this reason, we require not to have mutual recursion in the examined calls (it should be eliminated using the standard technique) and analyze them in the order of topological sorting. For $pref$ call we will need this information for the internal call $incr = $ \lstinline{incr-list$^o$ $\overline{l}$ $\underline{pti}$}. Here we just give it without details of analysis (the analysis is much simpler than that for the $pref$ call): the practical tests are satisfied, the answers are $ANS^{incr}(l) = \{[\underline{pti} \gets \overline{l'}] \; \mid \; length(l) = length(l') \land \forall i, \; l[i] = l'[i] \}$, and the complexity of the metrics is as follows.

\[ \begin{array}{l}
 d^{incr}(l) \in \O(length(l)) \\
 t_s^{incr}(l) \in \O(length(l)) \\
 t_{uni}^{incr}(l) \in \O(length(l)) \\
 t_{occ}^{incr}(l) \in \O(size(l)) \\
 t_{r}^{incr}(l) \in \O(size(l)) \\
 \textit{where} \\
 size(l) = \sum_{x \in l} |x| \\
\end{array} \]

\begin{figure}[t]
\begin{center}
\xymatrix{
     & \texttt{prefix$^o$ $\overline{k}$ $\underline{p}$} \ar[dl] \ar[dr] & \\
     \underline{p} \equiv \texttt{Nil} \ar[d]^{\{ [\underline{p} \gets \texttt{Nil}] \}} & & \overline{k} \equiv \texttt{S $\underline{n'}$} \ar[d]^{\{ [\underline{n'} \gets \overline{k'}] \; \mid \; \overline{k} \;=\; \texttt{S $\overline{k'}$} \}} \\
     & & \texttt{prefix$^o$ $\overline{k'}$ $\underline{pt}$} \ar@2[d]^{ \{[\underline{pt} \gets \overline{l}] \; \mid \; \textit{$l$ is a prefix of the list $[0..k' - 1]$} \} } \ar@{-->}[uul] \\
     & & \texttt{incr-list$^o$ $\overline{l}$ $\underline{pti}$} \ar[d]^{ \{[\underline{pti} \gets \overline{l'}] \; \mid \; length(l) = length(l') \land \forall i, \; l[i] = l'[i] \} } \\
     & & \underline{p} \equiv \texttt{Cons (O, $\overline{l'}$)} \ar[d]^{ \{[\underline{p} \gets \texttt{Cons (O, $\overline{l'}$)}] \} } \\
     & & \\
}
\end{center}

\caption{Symbolic execution scheme for the prefixes relation}
\label{fig:prefixo_scheme}
\end{figure}


The symbolic execution scheme for \lstinline|prefix$^o$| relation is shown on \figureword~\ref{fig:prefixo_scheme}. It shows the actual value of terms under the current substitution in all unifications and calls at the point when they are performed and the answers that are threaded through the search. It has initial call at the top. For simplicity we work only with the relations in disjunctive normal form, each disjuct is represented as a separate column on the scheme. The nodes of the coloumn are the unifications and relational calls in the given conjunct, they are written down sequentially in the same order as in the relation and connected by arrows. Arrows are labeled with the description of a set of answers, produced by the previous node. It is represented as a set of lists of bindings for logical variables by which the substitution is extended, the generator of the set (the condition after the `$\mid$' symbol) is described in metatheory. For the analysis we need to distinguish cases when multiple answers are produced so we denote by a single arrow $\downarrow$ the sets that we know to have no more than one answer, and put a double arrow $\Downarrow$ in other cases. The answers produced by internal relational calls are given as a prerequisite for the analysis. The unifications may produce new substitutions for both logic variables and symbolic variables. The definition of unification with both logic and symbolic variables is shown on \figureword~\ref{fig:symbolic_unification}. Bindings for logical variables in the result are extensions of the substitution in the environment after this unification, and bindings for symbolic variables are conditions on the objects in metatheory represented by these symbolic variables, under which we continue to execute the current branch (for example, the unification for $\overline{x} \equiv f(t_1, \dots, t_k)$ will succeed only for object $x$ such that its representation $\overline{x}$ is $f(\overline{x_1}, \dots, \overline{x_k})$, where $\overline{x_i}$ are representations which are terms unifiable with $t_i$). So we add bindings for symbolic variables to the generator of the set in form of equalities. We apply bindings for both logic and symbolic variables in all nodes after we get them to have show fully substituted values of terms. We also mark the recursive internal relational calls (the versions of initial relational call with symbolic variables substituted by arbitrary expressions and the rest alpha-equivalent to the initial call) by the dashed arrow to the root.

\begin{figure}[t]
\[
\begin{array}{lll}
  U(\underline{w}, \underline{w}) &= \epsilon & \\
  U(\underline{w}, t) &= \bot & \textit{if $\underline{w} \in FV(t)$} \\
  U(\underline{w}, t) &= [\underline{w} \gets t] & \textit{if $t \ne \underline{w} \land \underline{w} \not\in FV(t)$} \\
  U(\overline{x}, \underline{w}) &= [\underline{w} \gets \overline{x}] &  \\
  U(\overline{x}, \overline{y}) &= [\overline{x} \gets \overline{y}] &  \\
  U(\overline{x}, f(t_1, \dots, t_k)) &= [\overline{x} \gets f(\overline{x_1}, \dots, \overline{x_k})] \circ U(\overline{x_1}, t_1) \circ \dots \circ U(\overline{x_k}, t_k)  & \textit{where $\overline{x_i}$ are fresh}  \\
  U(f(t_1, \dots, t_k), \underline{w}) &= \bot & \textit{if $\underline{w} \in FV(f(t_1, \dots, t_k))$} \\
  U(f(t_1, \dots, t_k), \underline{w}) &= [\underline{w} \gets f(t_1, \dots, t_k)] & \textit{if $\underline{w} \not\in FV(f(t_1, \dots, t_k))$} \\
  U(f(t_1, \dots, t_k), \overline{x}) &= [\overline{x} \gets f(\overline{x_1}, \dots, \overline{x_k})] \circ U(t_1, \overline{x_1}) \circ \dots \circ U(t_k, \overline{x_k})  & \textit{where $\overline{x_i}$ are fresh}  \\
  U(f(t_1, \dots, t_k), f(t'_1, \dots, t'_k)) &= U(t_1, t'_1) \circ \dots \circ U(t_k, t'_k)  & \\
  U(f(t_1, \dots, t_k), g(t'_1, \dots, t'_{k'})) &= \bot  & \textit{if $f \ne g$} \\
  
\end{array}
\]
  \caption{Unification for terms with logic and symbolic variables. $t$ stands for an arbitrary term.}
  \label{fig:symbolic_unification}
\end{figure}

This scheme presents all the information we need to check the practical tests and calculate the complexity of all the metrics using results from the previous sections.

\begin{enumerate}
\item To check that all substitutions are flat during the evaluation we need to know that all non-recursive internal calls satisfy this condition and to check that no variable-to-variable bindings are added during the evaluation of the body of the relation. To check this we can simply check that rhs of all bindings on arrows after unifications are not logical variables (then the value in the binding
necessarily has a constructor on the top level).

If there is no recursive calls in the scheme, we can allow variable-to-variable bindings after substitutions, since there will be at most a constant number of them and substitutions will always be constantly flat.

The second practical test (linearity and constant size of one of the terms for every unification) we can easily check directly: for every unification on the scheme each logical variables should occur at most once and one of the terms should have no symbolic variables. We also need the test to be satisfied for all the internal calls.

\item To estimate $d^{pref}(k)$ we use lemmas \ref{lem:disjunction_metrics_calc} and \ref{lem:conjunction_metrics_calc}. Specifically, we just add the value of the metrics for every internal call (for non-recursive internal calls we have the estimation up to a multiplicative constant calculated before, for recursive internal calls it's just the value of the same function on a different argument) summed for all the answers on which the call is executed, and also add a constant to handle the rest (unifications and fresh variable introductions).

\[ d^{pref}(k) \le \sum_{\overline{k} \;=\; \texttt{S $\overline{k'}$}} (d^{pref}(k') + \sum_{\textit{$l$ is a prefix of the list $[0..k' - 1]$}} d^{incr}(l)) + C \]

Using the complexity $d^{incr}(l) \in \O(length(l))$ and considering to cases when $k$ is zero or non-zero we can rewrite and simplify the inequality above into the following two.

\[ \begin{array}{l}
d^{pref}(0) \le C \\
d^{pref}(k' + 1) \le d^{pref}(k') + \sum_{i \in [0..k' - 1]} C \cdot i + C \\
\phantom{d^{pref}(k' + 1)} \le d^{pref}(k') + C \cdot k'^2 \\
\end{array} \]

Which we can easily solve and get $d^{pref}(k) \in \O(k^3)$.

\item For $t_s^{pref}(k)$ we do basically the same using the same lemmas. There difference is that for every internal call $q$ along with $t_S^q(\dots)$ we have to add the $d^q(\dots)$ multiplied by a constant (for recursive calls we use the complexity calculated at the previous step). There is a possible exception however (identified in the lemmas \ref{lem:disjunction_metrics_calc} and \ref{lem:conjunction_metrics_calc}): for one column that has only single arrows we can omit additional $d^q(dots)$ for the call in the end of the column (if the column ends with a call). By lemma~\ref{lem:disjunction_metrics_calc} we can pick any one column, it might make difference only when this value $d^q(dots)$ dominates all the other additional values (so it only matters when the last call is recursive call, for example). In our example there is no columns ending with a call, so there is no such exception in inequality.

\[ t_s^{pref}(k) \le \sum_{\overline{k} \;=\; \texttt{S $\overline{k'}$}} (t_s^{pref}(k') + C \cdot d^{pref}(k') + \sum_{\textit{$l$ is a prefix of the list $[0..k' - 1]$}} (t_s^{incr}(l) + C \cdot d^{incr}(l))) + C \]

Again, after the simplification we get the following two inequalities.

\[ \begin{array}{l}
t_s^{pref}(0) \le C \\
t_s^{pref}(k' + 1) \le t_s^{pref}(k') + C \cdot k'^3 + \sum_{i \in [0..k' - 1]} (C \cdot i + C \cdot i) + C \\
\phantom{t_s^{pref}(k' + 1)} \le t_s^{pref}(k') + C \cdot k'^3 \\
\end{array} \]

And after solving them we get $t_s^{pref}(k) \in \O(k^4)$.

\item To estimate $t_{uni}^{pref}(k)$ we just do the same summation, counting the number of unification on the scheme and in the internal calls.

\[ t_{uni}^{pref}(k) \le 1 + 1 + \sum_{\overline{k} \;=\; \texttt{S $\overline{k'}$}} (t_{uni}^{pref}(k') + \sum_{\textit{$l$ is a prefix of the list $[0..k' - 1]$}} (t_{uni}^{incr}(l) + \sum_{l': \; length(l) = length(l') \land \forall i, \; l[i] = l'[i]} 1)) \]

The simplified version is the following.

\[ \begin{array}{l}
t_{uni}^{pref}(0) \le C \\
t_{uni}^{pref}(k' + 1) \le C + t_{uni}^{pref}(k') + \sum_{i \in [0..k' - 1]} (C \cdot i + 1) \\
\phantom{t_{uni}^{pref}(k' + 1)} \le t_{uni}^{pref}(k') + C \cdot k'^2
\end{array} \]

And the result is $t_{uni}^{pref}(k) \in \O(k^3)$.

\item To estimate $t_{occ}^{pref}(k)$ we just do the same summation, counting the sizes of rhs in bindings on arrows after every unification on the scheme and the same in the internal calls.

\[ \begin{array}{c} t_{occ}^{pref}(k) \le C + \sum_{\overline{k} \;=\; \texttt{S $\overline{k'}$}} (k' + t_{occ}^{pref}(k') + \sum_{\textit{$l$ is a prefix of the list $[0..k' - 1]$}} (t_{occ}^{incr}(l) + \\ \sum_{l': \; length(l) = length(l') \land \forall i, \; l[i] = l'[i]} size(\texttt{Cons (O, $\overline{l'}$)}))) \end{array} \]

The simplified version is the following.

\[ \begin{array}{l}
t_{occ}^{pref}(0) \le C \\
t_{occ}^{pref}(k' + 1) \le C + k' + t_{occ}^{pref}(k') + \sum_{i \in [0..k' - 1]} (C \cdot i^2 + C \cdot i^2 + 1) \\
\phantom{t_{occ}^{pref}(k' + 1)} \le t_{occ}^{pref}(k') + C \cdot k'^3 \\
\end{array} \]

And the result is $t_{occ}^{pref}(k) \in \O(k^4)$.

\item Finally, to estimate $t_{r}^{pref}(k)$ we just summarize sized of all answers from $ANS^{pref}(k)$.

$t_{r}^{pref}(k) = \sum_{\textit{$l$ is a prefix of the list $[0..k - 1]$}} size(l) \le \sum_{i \in [0..k - 1]} C \cdot i^2 \le C \cdot k^3$

So $t_{r}^{pref}(k) \in \O(k^3)$.

\end{enumerate}

This way we get the complexity for all the components of the search we can then combine to get the full time. To get the time related to the unification we should multiply $t_{uni}^{pref}$, $t_{occ}^{pref}$, $t_r^{pref}$ metrics by a factor $(\lookuptime{|\sigma|} + \addtime{|\sigma|}))$ which we can estimate by $(\lookuptime{d^{pref}(k)} + \addtime{d^{pref}(k)}))$. So, for example, for an implementation with standard-library maps for substitutions the full time of the search for the call \lstinline{prefix$^o$ $\overline{k}$ $\underline{a}$} will be $\O(k^4 + k^3 \log k + k^4 \log k + k^3 \log k) = \O(k^4 \log k)$ in the presence of occurs checks and $\O(k^4 + k^3 \log k + k^3 \log k) = \O(k^4)$ if we ommit occurs checks.
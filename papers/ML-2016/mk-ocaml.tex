\documentclass[10pt, oneside, nocopyrightspace]{sigplanconf}

\usepackage{amssymb}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref}

\topmargin 2.0cm
\setlength{\textheight}{25.3cm}

\lstdefinelanguage{ocaml}{
keywords={let, begin, end, in, match, type, and, fun, function, try, with, when, class, 
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit, 
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual},
sensitive=true,
basicstyle=\small,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\;\;\to\;\;$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=~,
language=ocaml
}

\sloppy

\newcommand{\miniKanren}{\texttt{miniKanren}}

\begin{document}

\title{Typed Embedding of Relational Language in OCaml}

\authorinfo{Dmitry Kosarev \and Dmitri Boulytchev}
{St.Petersburg State University \\ 
  Saint-Petersburg, Russia }
{$\mathtt{dboulytchev@gmail.com}$ \and $\mathtt{dboulytchev@math.spbu.ru}$}

\maketitle

\small
\section{Introduction}

Relational programming~\cite{TRS} is an attractive technique, based on the idea 
of constructing programs as relations.  As a result, relational programs can be
``queried'' in various ``directions'', making it possible, for example, to simulate
reversed execution. Apart from being interesting from purely theoretical standpoint, 
this approach may have a practical value: some problems look much simpler, 
if they are considered as queries to relational specification. There is a 
number of appealing examples, confirming this observation: a type checker 
for simply typed lambda calculus (and, at the same time, type inferencer and solver 
for the inhabitation problem), an interpreter (capable of generating ``quines''~--- 
programs, producing themselves as result)~\cite{Untagged}, list sorting (capable of 
producing all permutations) etc. 

Many logic programming languages, such as Prolog, Mercury\footnote{\url{https://mercurylang.org}}, 
or Curry\footnote{\url{http://www-ps.informatik.uni-kiel.de/currywiki}} to some extent
can be considered as relational. We have chosen, however, miniKanren\footnote{\url{http://minikanren.org}} 
as model language, because it was initially designed as relational DSL, embedded in Scheme/Racket. 
Being rather a minimalistic language, which can be implemented with just a few data structures 
and combinators, miniKanren found its way in dozens of host languages, including Haskell, 
Standard ML and OCaml.

There is, however, a predictable glitch in implementing miniKanren for strongly typed language. 
Designed in a metaprogramming-friendly and dynamically typed realm of Scheme/Racket, original 
miniKanren implementation pays very little attention to what has a significant importance in (specifically) 
ML or Haskell. In particular, one of cupstone constructs of miniKanren~--- unification~--- has to work for 
different data structures, which may have different (beyond parametricity) types.

There are a few ways to overcome this problem. The first one is simply to follow the untyped paradigm and
provide unification for some concrete type, rich enough to represent any reasonable data structures.
Some Haskell miniKanren libraries\footnote{\url{https://github.com/JaimieMurdock/HK}, \url{https://github.com/rntz/ukanren}}
as well as existing OCaml implementation\footnote{\url{https://github.com/lightyang/minikanren-ocaml}} take this way. 
As a result, the original implementation can be retold with all its elegance; relational specifications, however,
become weakly typed. Another approach is to utilize \emph{ad hoc} polymorphism and provide type-specific
unification for each ``interesting'' type; Molog\footnote{\url{https://github.com/acfoltzer/Molog}} and 
MiniKanrenT\footnote{\url{https://github.com/jvranish/MiniKanrenT}}, both for Haskell, can be mentioned as examples.
While preserving strong typing, this approach requires a lot of ``boilerplate'' code to be written, so some
automation, for example, using Template Haskell\footnote{\url{https://wiki.haskell.org/Template_Haskell}},
is desirable. There is, actually, another potential approach, but we do not know, if anybody tried
it: to implement unification for generic representation of types as sum-of-products and fixpoints of 
functors~\cite{InstantGenerics, ALaCarte}. Thus, unification would work for any types, for which representation
is provided. We assume, that implementing representation would require less boilerplate code.

As it follows from given exposition, typed embeddeing of miniKanren in OCaml requires
a combination of datatype-generic programming~\cite{DGP} and \emph{ad hoc} polymorphism. There are a number of 
generic frameworks for OCaml (for example,~\cite{Deriving}); 

We present an implementation of a set of relational combinators in OCaml, which, 
technically speaking, correspond to $\mu$Kanren~\cite{MicroKanren} with disequality 
constraints~\cite{CKanren}. The contribution of our work is as follows:

\begin{enumerate}
\item Our implementation is based on \emph{polymorphic unification}, which, like polymorphic comparison,
can be used for almost arbitrary types. The implementation of polymorphic unification is unsafe and
relies on intrinsic knowledge of runtime representation of values; we show, however, that all code outside 
unification remains type-safe. 

\item We describe a uniform and scalable scenario for using types for relational programming, which
helps in converting typed data to- and from relational domain. For this scenario, only one
generic feature (``\lstinline{map/morphism/Functor}'') is needed, and thus virtually any generic 
framework for OCaml can be used.

\item We provide a simplified way to integrate relational and functional code. Our approach utilizes
well-known pattern~\cite{UNparsing, DoWeNeed} for variadic function implementation and 
\end{enumerate}

We also want to express our gratitude to William Byrd, who infected us with relational programming, for his 


\section{Logical Values, States, Goals and Toplevel Primitives}

\begin{lstlisting}[mathescape=true]
type ('v, 'l) lam = 
  Lam of 'v * 'l | Var of 'v | Abs of 'l * 'l

type glam = (string      , glam) lam
type llam = (string logic, llam) lam logic

let rec inj_lam : glam -> llam = 
  fun l -> $\uparrow$($map^{lam}$ ($\uparrow$) inj_lam l)

let rec prj_lam : llam -> glam =
  fun l -> $map^{lam}$ ($\downarrow$) prj_lam @@ $\downarrow$l
\end{lstlisting}

injection, projection, mapping and generic programming.

\section{Polymorphic Unification}

We consider it rather natural to employ polymorphic unification in the
language, already equipped with polymorphic comparison~--- a convenient, but
somewhat disputable\footnote{See, for example, \url{https://blogs.janestreet.com/the-perils-of-polymorphic-compare}} 
feature. Like polymorphic comparison, polymorphic unification performs traversal
of values, exploiting intrinsic knowledge of their runtime representation. 
The undeniable benefit of this solution is that in order to perform unification 
for user types no ``boilerplate'' code is needed. On the other hand, all pitfalls of
polymorphic comparison are inherited as well; in particular, unification can loop 
for cyclic data structures and does not work for functional values. Since we generally 
do not expect any reasonable outcome in these cases, the only remaining problem is that
the compiler is uncapable to provide any assistance in identifying 
and avoiding them. Another drawback is that the implementation of polymorphic unification
relies on runtime representation of values and have to be fixed every time the representation changes. 
Finally, as it written in unsafe manner using \lstinline{Obj} interface, it has to be
carefully developed and tested.

An important difference between polymorphic comparison and unification is that the former 
only inspects its operands, while the results of unification are recorded in a substitution
(mapping from logical variables to terms), which later is used to refine answers and reify 
constraints. So, generally speaking, we have to show, that no ill-typed terms are constructed 
as a result.

Polymorphic unification is introduced via the following function:

\begin{lstlisting}[mathescape=true]
val unify : 
  $\alpha$ logic -> $\;\;\alpha$ logic -> $\;\;$subst option -> $\;\;$subst option
\end{lstlisting}

\noindent where ``\lstinline{subst}'' stands for the type of substitution. Unification can 
fail (hence ``\lstinline{option}'' in the result type), is performed in the context of
existing substitution (hence ``\lstinline{subst}'' in the third argument) and
can be chained (hence ``\lstinline{option}'' in the third argument). Note, that the 
type of substitution is not polymorphic, which means, that compiler competely looses the 
track of types for values, stored in a substitution. These types are recovered later during
refinement of answers.

To justify the correctness of unification, we consider the set of typed terms, each of which
has one of two forms

$$
x^\tau \mid C^\tau(t_1^{\tau_1},\dots,t_k^{\tau_k})
$$

\noindent where $x^\tau$ denotes a logical variable of type $\tau$, 
$C^\tau$~--- some constructor of type $\tau$, $t_i^{\tau_i}$~--- some terms of types $\tau_i$.
We reflect by $t_1^\tau[t_2^\rho]$ the fact of $t_2^\rho$ being a subterm of $t_1^\tau$, and
assume, that $\rho$ is unabiguously determined by $t_1$, $\tau$, and a position of $t_2$ 
``inside'' $t_1$.

Outside unification the compiler maintains typing, which means, that all 
terms, subterms, and variables agree in their types in all contexts. However, as 
our implementation resorts to unsafe features, we have to make this work for unification
code on our own.

We argue, that the following three invariants are maintained for any substitution $s$, involved 
in unification:

\begin{enumerate}
\item if \mbox{$t_1^{\_}[x^{\tau}]$} and \mbox{$t_2^{\_}[x^{\rho}]$}~--- two arbitrary terms (in particular, 
$t_1^{\_}$ and $t_2^{\_}$ may be the same), bound in $s$ and containing occurrences of variable $x$, 
then $\rho=\tau$ (different occurrences of the same variable in $s$ are attributed with the same type);

\item if \mbox{$(s\;\;x^\tau)$} is defined, then \mbox{$(s\;\;x^\tau) = t^\tau$} (a substitution always
binds a variable to a term of the same type);

\item each variable in $s$ preserves its type, assigned by the compiler (from the first two invariants 
it is follows, that this type is unique; note also, that all variables are created and have their 
types assigned outside unification, in a type-safe world).
\end{enumerate}

The initial (empty) substitution trivially fulfills these invariants; hence, it is sufficient
to show, that they are preserved by unification.

The following snippet presents the implementation of unification with triangular 
substitution in only a little bit more abstract form, than actual code (for example, 
``occurs check'' is omitted):

\begin{lstlisting}[mathescape=true,numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=5pt]
let rec walk $s$ = function
| $x^\tau$ when $x\in dom(s)$ -> $\;\;$walk $s$ $(s\;\;x)^\tau$
| $t^\tau$ -> $\;\;t^\tau$

let rec unify $t_1^\tau$ $t_2^\tau$ = function
| None -> None
| Some $s$ as $sub$  ->
    match walk $s$ $t_1$, walk $s$ $t_2$ with
    | $x_1^\tau$, $x_2^\tau$ when $x_1$ = $x_2$ -> $\;\;sub$
    | $x_1^\tau$, $(t_2^\prime)^\tau$ -> $\;\;$Some ($s[x_1 \gets t_2^\prime]$)
    | $(t_1^\prime)^\tau$, $x_2^\tau$ -> $\;\;$Some ($s[x_2 \gets t_1^\prime]$)
    | $C^\tau(t_1^{\tau_1},\dots,t_k^{\tau_k})$, $C^\tau(p_1^{\tau_1},\dots,p_k^{\tau_k})$ -> 
        unify $t_k^{\tau_k}$ $p_k^{\tau_k}$$(..$(unify $t_2^{\tau_2}$ $p_2^{\tau_2}$ (unify $t_1^{\tau_1}$ $p_1^{\tau_1}$ $sub$))$..$)
    | $\_$, $\_$ -> $\;\;$None
\end{lstlisting}

Type annotations, included in the snippet above, can be justified by the following 
reasonings\footnote{We omit the verbal description of unification algorithm due to a
looming lack of space; the details can be found in~\cite{MicroKanren}.}:

\begin{enumerate}
\item Line 2: the type of \mbox{$(s\;\;x^\tau)$} is $\tau$ due to the invariant 2; hence, 
the type of \lstinline{walk} result coincides with the type of its second argument.

\item Line 9: the substitution is left unchanged, hence all invariants are preserved.

\item Line 10 (and, symmetrically, line 11): first, note, that \mbox{$(s\;\;x_1)$} is undefined
(otherwise \lstinline{walk} would not return $x_1$). Then, $x_1$ and $t_2^\prime$ have the
same type, which justifies the preservation of invariant 2. Finally, either \mbox{$x_1=t_1$}
(and, then, $\tau$ is the type of $x_1$, assigned by the compiler), or $x_1$ is retrieved
from $s$ with type $\tau$~--- both cases justify invariants 1 and 3. The same applies to 
the pair $t_2^\prime$ and $t_2$.
\end{enumerate}

Induction; environment and variable recognition; (===) and (=/=).

\section{Refinement}

\section{Examples}

\section{Conclusion}

\begin{thebibliography}{99}
\bibitem{TRS}
Daniel P. Friedman, William E.Byrd, Oleg Kiselyov. The Reasoned Schemer. The MIT
Press, 2005.

\bibitem{MicroKanren}
Jason Hemann, Daniel P. Friedman. $\mu$Kanren: A Minimal Core for Relational Programming //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13).

\bibitem{CKanren}
Claire E. Alvis, Jeremiah J. Willcock, Kyle M. Carter, William E. Byrd, Daniel P. Friedman.
cKanren: miniKanren with Constraints // 
Proceedings of the 2011 Workshop on Scheme and Functional Programming (Scheme '11).

\bibitem{Untagged}
William E. Byrd, Eric Holk, Daniel P. Friedman.
miniKanren, Live and Untagged: Quine Generation via Relational Interpreters (Programming Pearl) //
Proceedings of the 2012 Workshop on Scheme and Functional Programming (Scheme '12).

\bibitem{Implicits}
Leo White, Fr\'ed\'eric Bour, Jeremy Yallop. 
Modular Implicits // Workshop on ML, 2014, arXiv:1512.01438.

\bibitem{Unparsing}
Olivier Danvy.
Functional Unparsing // Journal of Functional Programming, Vol.~8, Issue~6, November 1998.

\bibitem{DoWeNeed}
Daniel Fridlender, Mia Indrika.
Do we need dependent types? // Journal of Functional Programming, Vol.~10, Issue~4, July 2000.

\bibitem{DGP}
Jeremy Gibbons. Datatype-generic Programming //
Proceedings of the 2006 International Conference on Datatype-generic Programming.

\bibitem{Deriving}
Jeremy Yallop. 
Practical Generic Programming in OCaml // Proceedings of 2007 Workshop on ML.

\bibitem{InstantGenerics}
Manuel M. T. Chakravarty, Gabriel C. Ditu, Roman Leshchinskiy. 
Instant Generics: Fast and Easy. \url{http://www.cse.unsw.edu.au/~chak/papers/CDL09.html}, 2009.

\bibitem{ALaCarte}
Wouter Swierstra. Data Types \'a la Carte  // Journal of Functional Programming, Vol.~18, Issue~4, 2008.
\end{thebibliography}

\end{document}

